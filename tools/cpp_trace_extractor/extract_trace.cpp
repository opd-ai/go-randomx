/*
 * RandomX Reference Trace Extractor
 * 
 * This tool extracts intermediate values from the official RandomX C++
 * reference implementation to help debug the go-randomx implementation.
 * 
 * Usage: ./extract_trace <key> <input>
 * 
 * Output: JSON trace containing intermediate values
 */

#include "randomx.h"
#include <cstdio>
#include <cstring>
#include <cstdint>
#include <cstdlib>

// Print a hex-encoded byte array
void print_hex(const char* name, const void* data, size_t len) {
    printf("  \"%s\": \"", name);
    const unsigned char* bytes = (const unsigned char*)data;
    for (size_t i = 0; i < len; i++) {
        printf("%02x", bytes[i]);
    }
    printf("\"");
}

// Print an array of uint64 values as hex strings
void print_u64_array(const char* name, const uint64_t* values, int count) {
    printf("  \"%s\": [\n", name);
    for (int i = 0; i < count; i++) {
        printf("    \"0x%016lx\"", (unsigned long)values[i]);
        if (i < count - 1) {
            printf(",\n");
        } else {
            printf("\n");
        }
    }
    printf("  ]");
}

int main(int argc, char** argv) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <key> <input>\n", argv[0]);
        fprintf(stderr, "\n");
        fprintf(stderr, "Examples:\n");
        fprintf(stderr, "  %s \"test key 000\" \"This is a test\"\n", argv[0]);
        fprintf(stderr, "  %s \"test key 000\" \"Lorem ipsum dolor sit amet\"\n", argv[0]);
        fprintf(stderr, "\n");
        fprintf(stderr, "Output: JSON trace with intermediate values\n");
        return 1;
    }
    
    const char* key = argv[1];
    const char* input = argv[2];
    size_t key_len = strlen(key);
    size_t input_len = strlen(input);
    
    // Initialize RandomX in light mode (compatible with go-randomx tests)
    randomx_flags flags = randomx_get_flags();
    // Don't use RANDOMX_FLAG_FULL_MEM to match light mode tests
    
    randomx_cache* cache = randomx_alloc_cache(flags);
    if (!cache) {
        fprintf(stderr, "Error: Failed to allocate cache\n");
        return 1;
    }
    
    randomx_init_cache(cache, key, key_len);
    
    randomx_vm* vm = randomx_create_vm(flags, cache, NULL);
    if (!vm) {
        fprintf(stderr, "Error: Failed to create VM\n");
        randomx_release_cache(cache);
        return 1;
    }
    
    // Calculate hash
    char hash[RANDOMX_HASH_SIZE];
    randomx_calculate_hash(vm, input, input_len, hash);
    
    // Output JSON trace
    printf("{\n");
    printf("  \"test_name\": \"cpp_reference\",\n");
    printf("  \"key\": \"");
    for (size_t i = 0; i < key_len; i++) {
        if (key[i] == '"' || key[i] == '\\') printf("\\");
        printf("%c", key[i]);
    }
    printf("\",\n");
    printf("  \"input\": \"");
    for (size_t i = 0; i < input_len; i++) {
        if (input[i] == '"' || input[i] == '\\') printf("\\");
        else if (input[i] == '\n') printf("\\n");
        else if (input[i] == '\t') printf("\\t");
        else printf("%c", input[i]);
    }
    printf("\",\n");
    
    // Output final hash
    print_hex("final_hash", hash, RANDOMX_HASH_SIZE);
    printf(",\n");
    
    printf("  \"note\": \"This trace was generated by the RandomX C++ reference implementation\",\n");
    printf("  \"note2\": \"To add intermediate values, modify the RandomX source to output state at key points\",\n");
    printf("  \"note3\": \"For now, this provides the expected final hash for validation\"\n");
    printf("}\n");
    
    // Cleanup
    randomx_destroy_vm(vm);
    randomx_release_cache(cache);
    
    return 0;
}
